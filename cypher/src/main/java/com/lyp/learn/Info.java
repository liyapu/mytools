package com.lyp.learn;

/**
 *   现代密码学
 *      ① 散列函数
 *         散列函数，也见杂凑函数、摘要函数或哈希函数，可将任意长度的消息经过运算，变成固定长度数值，
 *         常见的有MD5、SHA-1、SHA256，多应用在文件校验，数字签名中。
 *
 *        MD5 可以将任意长度的原文生成一个128位（16字节）的哈希值
 *        SHA-1可以将任意长度的原文生成一个160位（20字节）的哈希值
 *
 *        消息摘要
 *             消息摘要（Message Digest）又称为数字摘要(Digital Digest)
 *             它是一个唯一对应一个消息或文本的固定长度的值，它由一个单向Hash加密函数对消息进行作用而产生
 *             使用数字摘要生成的值是不可以篡改的，为了保证文件或者值的安全
 *
 *             特点
 *                无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。
 *                例如应用MD5算法摘要的消息有128个比特位，用SHA-1算法摘要的消息最终有160比特位的输出
 *
 *                只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出
 *                消息摘要是单向、不可逆的
 *
 *             常见算法 :
 *               - MD5
 *               - SHA1
 *               - SHA256
 *               - SHA512
 *             总结
 *                 MD5算法 : 摘要结果16个字节, 转16进制后32个字节
 *                 SHA1算法 : 摘要结果20个字节, 转16进制后40个字节
 *                 SHA256算法 : 摘要结果32个字节, 转16进制后64个字节
 *                 SHA512算法 : 摘要结果64个字节, 转16进制后128个字节
 *
 *     ② 对称密码
 *       对称密码应用了相同的加密密钥和解密密钥。
 *       对称密码分为：
 *           序列密码(流密码)，
 *           分组密码(块密码)两种。
 *
 *           流密码是对信息流中的每一个元素（一个字母或一个比特）作为基本的处理单元进行加密，
 *           块密码是先对信息流分块，再对每一块分别加密。
 *
 *          例如原文为1234567890，
 *          流加密即先对1进行加密，再对2进行加密，再对3进行加密……最后拼接成密文；
 *          块加密先分成不同的块，如1234成块，5678成块，90XX(XX为补位数字)成块，再分别对不同块进行加密，最后拼接成密文。
 *
 *          前文提到的古典密码学加密方法，都属于流加密。
 *
 *    ③ 非对称密码
 *       对称密码的密钥安全极其重要，加密者和解密者需要提前协商密钥，并各自确保密钥的安全性，一但密钥泄露，即使算法是安全的也无法保障原文信息的私密性。
 *       在实际的使用中，远程的提前协商密钥不容易实现，即使协商好，在远程传输过程中也容易被他人获取，因此非对称密钥此时就凸显出了优势。
 *
 *      非对称密码有两支密钥，公钥（publickey）和私钥（privatekey），加密和解密运算使用的密钥不同。
 *      用公钥对原文进行加密后，需要由私钥进行解密；
 *      用私钥对原文进行加密后（此时一般称为签名），需要由公钥进行解密（此时一般称为验签）。
 *      公钥可以公开的，大家使用公钥对信息进行加密，再发送给私钥的持有者，私钥持有者使用私钥对信息进行解密，获得信息原文。
 *      因为私钥只有单一人持有，因此不用担心被他人解密获取信息原文。
 *
 *      非对称加密
 *         简介：
 *         ① 非对称加密算法又称现代加密算法。
 *         ② 非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。
 *         ③ 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey)
 *         ④ 公开密钥和私有密钥是一对
 *         ⑤ 如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。
 *         ⑥ 如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。
 *         ⑦ 因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
 *
 *         示例
 *           首先生成密钥对, 公钥为(5,14), 私钥为(11,14)
 *           现在A希望将原文2发送给B
 *           A使用公钥加密数据. 2的5次方mod 14 = 4 , 将密文4发送给B
 *           B使用私钥解密数据. 4的11次方mod14 = 2, 得到原文2
 *         特点
 *           加密和解密使用不同的密钥
 *           如果使用私钥加密, 只能使用公钥解密
 *           如果使用公钥加密, 只能使用私钥解密
 *           处理数据的速度较慢, 因为安全级别高
 *         常见算法
 *           RSA
 *           ECC
 *
 *
 *  加密模式
 *     加密模式：https://docs.oracle.com/javase/8/docs/api/javax/crypto/Cipher.html
 *
 *    ECB
 *        ECB : Electronic codebook, 电子密码本. 需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密
 *
 *        优点 : 可以并行处理数据
 *        缺点 : 同样的原文生成同样的密文, 不能很好的保护数据
 *        同时加密，原文是一样的，加密出来的密文也是一样的
 *
 *   CBC
 *       CBC : Cipher-block chaining, 密码块链接. 每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块
 *
 *       优点 : 同样的原文生成的密文不一样
 *       缺点 : 串行处理数据.
 *
 *
 *  填充模式
 *        当需要按块处理的数据, 数据长度不符合块处理需求时, 按照一定的方法填充满块长的规则
 *   NoPadding
 *        不填充.
 *        在DES加密算法下, 要求原文长度必须是8byte的整数倍
 *        在AES加密算法下, 要求原文长度必须是16byte的整数倍
 *
 *   PKCS5Padding
 *       数据块的大小为8位, 不够就补足
 *
 *     Tips
 *        默认情况下, 加密模式和填充模式为 : ECB/PKCS5Padding
 *        如果使用CBC模式, 在初始化Cipher对象时, 需要增加参数, 初始化向量IV :
 *        IvParameterSpec iv = new IvParameterSpec(key.getBytes());
 *
 *  加密模式和填充模式
 *      AES/CBC/NoPadding (128)
 *      AES/CBC/PKCS5Padding (128)
 *      AES/ECB/NoPadding (128)
 *      AES/ECB/PKCS5Padding (128)
 *
 *      DES/CBC/NoPadding (56)
 *      DES/CBC/PKCS5Padding (56)
 *      DES/ECB/NoPadding (56)
 *      DES/ECB/PKCS5Padding (56)
 *
 *      DESede/CBC/NoPadding (168)
 *      DESede/CBC/PKCS5Padding (168)
 *      DESede/ECB/NoPadding (168)
 *      DESede/ECB/PKCS5Padding (168)
 *
 *      RSA/ECB/PKCS1Padding (1024, 2048)
 *      RSA/ECB/OAEPWithSHA-1AndMGF1Padding (1024, 2048)
 *      RSA/ECB/OAEPWithSHA-256AndMGF1Padding (1024, 2048)
 *
 *
 *
 *  Base64 算法简介
 *          Base64是网络上最常见的用于传输8Bit字节码的可读性编码算法之一
 *          可读性编码算法不是为了保护数据的安全性，而是为了可读性
 *          可读性编码不改变信息内容，只改变信息内容的表现形式
 *          所谓Base64，即是说在编码过程中使用了64种字符：大写A到Z、小写a到z、数字0到9、“+”和“/”
 *
 *         Base58是Bitcoin(比特币)中使用的一种编码方式，主要用于产生Bitcoin的钱包地址
 *         相比Base64，Base58不使用数字"0"，字母大写"O"，字母大写"I"，和字母小写"i"，以及"+"和"/"符号
 *
 *
 *        Base64 算法原理
 *            base64 是 3个字节为一组，一个字节 8位，一共 就是24位 ，Base64那，把3个字节转成4组，每组6位，
 *            3 * 8 = 4 * 6 = 24 ，每组6位，缺少的2位，会在高位进行补0 ，这样做的好处在于 ，base取的是后面6位，去掉高2位 ，
 *            那么base64的取值就可以控制在0-63位了，所以就叫base64，111 111 = 32 + 16 + 8 + 4 + 2 + 1 =
 *
 *           base64 构成原则
 *             ① 小写 a - z = 26个字母
 *             ② 大写 A - Z = 26个字母
 *             ③ 数字 0 - 9 = 10 个数字
 *             ④ + / = 2个符号
 *
 *           大家可能发现一个问题，咱们的base64有个 = 号，但是在映射表里面没有发现 = 号 ，
 *           这个地方需要注意，等号非常特殊，因为base64是三个字节一组 ，如果当我们的位数不够的时候，会使用等号来补齐
 *
 *
 *  PGP——密码技术的完美组合
 *  https://www.jianshu.com/p/91c98a27fd16
 *
 *
 *
 *    数字签名
 *        数字签名（又称公钥数字签名）是只有信息的发送者才能产生的别人无法伪造的一段数字串，
 *        这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。
 *        它是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术来实现的，用于鉴别数字信息的方法。
 *        一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。
 *        数字签名是非对称密钥加密技术与数字摘要技术的应用。
 *
 */
public interface Info {
}
