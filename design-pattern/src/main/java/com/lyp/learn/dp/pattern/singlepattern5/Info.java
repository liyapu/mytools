package com.lyp.learn.dp.pattern.singlepattern5;

/**
 * @author liyapu
 * @date 2023-03-08 09:42
 * 重点总结。
 * 概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：
 * <p>
 * 构造函数需要是private访问权限的，这样才能避免外部通过new创建实例；
 * 考虑对象创建时的线程安全问题；
 * 考虑是否支持延迟加载；
 * 考虑getInstance()性能是否高（是否加锁）。
 * 如果你对这块已经很熟悉了，你可以当作复习。注意，下面的几种单例实现方式是针对Java语言语法的，
 * 如果你熟悉的是其他语言，不妨对比Java的这几种实现方式，自己试着总结一下，利用你熟悉的语言，该如何实现。
 *
 * <p>
 * 1.单例的定义
 * 单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），
 * 那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。
 * <p>
 * 2.单例的用处
 * <p>
 * 从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。
 * <p>
 * 3.单例的实现
 * <p>
 * 单例有下面几种经典的实现方式。
 * <p>
 * 饿汉式
 * 饿汉式的实现方式，在类加载的期间，就已经将instance静态实例初始化好了，所以，instance实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。
 * <p>
 * 懒汉式
 * 懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。
 * <p>
 * 双重检测
 * 双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要instance被创建之后，再调用getInstance()函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。
 * <p>
 * 静态内部类
 * 利用Java的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。
 * <p>
 * 枚举
 * 最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。
 */
public interface Info {

}
