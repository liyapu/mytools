package com.lyp.learn.dp.pattern.singlepattern5;

/**
 * @author liyapu
 * @date 2023-03-08 09:42
 * 重点总结。
 * 概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：
 * <p>
 * 构造函数需要是private访问权限的，这样才能避免外部通过new创建实例；
 * 考虑对象创建时的线程安全问题；
 * 考虑是否支持延迟加载；
 * 考虑getInstance()性能是否高（是否加锁）。
 * 如果你对这块已经很熟悉了，你可以当作复习。注意，下面的几种单例实现方式是针对Java语言语法的，
 * 如果你熟悉的是其他语言，不妨对比Java的这几种实现方式，自己试着总结一下，利用你熟悉的语言，该如何实现。
 *
 * <p>
 * 1.单例的定义
 * 单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），
 * 那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。
 * <p>
 * 2.单例的用处
 * <p>
 * 从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。
 * <p>
 * 3.单例的实现
 * <p>
 * 单例有下面几种经典的实现方式。
 * <p>
 * 饿汉式
 * 饿汉式的实现方式，在类加载的期间，就已经将instance静态实例初始化好了，所以，instance实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。
 * <p>
 * 懒汉式
 * 懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。
 * <p>
 * 双重检测
 * 双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要instance被创建之后，再调用getInstance()函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。
 * <p>
 * 静态内部类
 * 利用Java的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。
 * <p>
 * 枚举
 * 最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。
 *
 * 如何理解单例模式中的唯一性？
 * 首先，我们重新看一下单例的定义：“一个类只允许创建唯一一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。”
 * 定义中提到，“一个类只允许创建唯一一个对象”。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。这里有点不好理解，我来详细地解释一下。
 * 我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如Windows下的exe文件）。可执行文件实际上就是代码被翻译成操作系统可理解的一组指令，你完全可以简单地理解为就是代码本身。
 * 当我们使用命令行或者双击运行这个可执行文件的时候，操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的User user = new User();这条语句的时候，它就在自己的地址空间中创建一个user临时变量和一个User对象。
 * 进程之间是不共享地址空间的，如果我们在一个进程中创建另外一个进程（比如，代码中有一个fork()语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如user临时变量、User对象）。
 * 所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的。
 */
public interface Info {

}
