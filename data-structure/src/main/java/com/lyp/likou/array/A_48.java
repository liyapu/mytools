package com.lyp.likou.array;

/**
 * @author liyapu
 * @date 2024-03-24 22:34
 * @description 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
 * 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
 *
 * 示例 1：
 * 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
 * 输出：[[7,4,1],[8,5,2],[9,6,3]]
 *
 * 示例 2：
 * 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
 * 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
 *
 *
 * 提示：
 * n == matrix.length == matrix[i].length
 * 1 <= n <= 20
 * -1000 <= matrix[i][j] <= 1000
 *
 * 一 、找到坐标变化规律
 * 长度为N的矩阵
 * 顺时针旋转 90 度后会发现
 * 第I行会变为倒数第I列
 * 第J列会变为第J行
 * 所以对应关系为[I,J] -> [J,N-1-I] （这里为N-1是因为坐标从0开始所以最大的坐标为N-1）
 * 旋转时每个坐标都有与之对应的3个坐标点,总共4个坐标点相互互换位置
 * [I,J] -> [J,N-1-I] -> [N-1-I,N-1-J] -> [N-1-J,I] -> [I,J]
 * 所以我们只需要遍历 1/4 的坐标,然后变动对应的 4 组坐标 即可实现全部坐标的替换
 *
 * 二、确定遍历范围
 * 遍历 1/4 的范围有两种方式
 *
 *
 * 图 1
 * 图一的遍历范围为 I(0-> N/2),J(0->N/2) 总面积为N/2 * N/2=N方/4
 * 是最容易想到的方式,相当于把正方形横竖分为 4 个小正方形
 * 当N为偶数时没有什么问题,但当N为奇数比如图中N为5时,总共5*5=25个点,去除最中间1个点无需变动,我们需要遍历 24/4=6个点
 * 这时候用此方式切割就没办法实现等分遍历了
 *
 * 图 2
 * 图二的遍历范围为 I(0->N),J(I->N-1-I) 总面积为 N * N/2 * 1/2=N方/4(三角形面积)
 * 相当于把正方形分为 4 个等腰直角三角形，(两条对角线进行分割，每个等腰直角三角形只要自己独占的点，与其它三角形攻占的，让给下个三角形)
 * 1 2 3     1 2 -    - - 3   - - -   - - -
 * 4 5 6 -》 - 5 -    - 5 6   - 5 8   4 5 -
 * 7 8 9     - - -   - - -    - - 9   7 - -
 * 这种分割方式即使 N 为奇数也可以正常等分,图例中可以在每个三角形中取到独占的 6 个点
 * 需要注意的是(0,4),(1,3) 这两个点不能包含起来 所以遍历的时候判断条件不能等于
 *
 * 所以使用图 2 的遍历方式 把遍历到的每个点和与之对应的其他三个点互换值即可实现旋转
 *
 * 三、不占用额外空间
 * 这时我们已经知道本题只需要找到正确的坐标对互换值即可
 * 题目中问到不占用额外内存空间能否做到？
 * 就是问如何不占用额外的内存空间,来交换A，B两个值
 * 聪明的你已经想到方法
 * A = A+B
 * B = A-B
 * A = A-B
 * 这三步之后我们就实现了不占用额外的内存空间,交换了 AB 的值
 *
 * 作者：Firesnow
 * 链接：https://leetcode.cn/leetbook/read/array-and-string/clpgd/?discussion=ut8ZJl
 * 来源：力扣（LeetCode）
 * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 */
public class A_48 {
    public void rotate(int[][] matrix) {
        //第一行的最后一个，不占用
        for (int i = 0; i < matrix.length - 1; i++) {
            for (int j = i; j < matrix.length - 1 - i; j++) {
                exchange(matrix, i, j, j, matrix.length - 1 - i);
                exchange(matrix, i, j, matrix.length - 1 - i, matrix.length - 1 - j);
                exchange(matrix, i, j, matrix.length - 1 - j, i);
            }
        }

    }

    public static void exchange(int[][] matrix, int i1, int j1, int i2, int j2) {
        matrix[i1][j1] = matrix[i1][j1] + matrix[i2][j2];
        matrix[i2][j2] = matrix[i1][j1] - matrix[i2][j2];
        matrix[i1][j1] = matrix[i1][j1] - matrix[i2][j2];
    }

    public static void main(String[] args) {
        new A_48().rotate(new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});
    }
}
